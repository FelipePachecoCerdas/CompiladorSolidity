package lexico;

import java_cup.runtime.Symbol;
import java.util.Stack;
import java.util.ArrayList;
import java.util.Iterator;

parser code
{:  public ArrayList<Symbol> errores = new ArrayList<>();
  public ArrayList<String> erroresStr = new ArrayList<>();
  
  public void syntax_error(Symbol s) {
    System.out.println("ERROR EN " + s.value + " " + Integer.toString(s.right + 1) + ": " + Integer.toString(s.left + 1) );
    String cadena = "";
    for (int i = this.stack.size() - 1; i > 0; i--) {
      Symbol sp = this.stack.get(i);
       
      System.out.println(sp.value + " " + Integer.toString(sp.right + 1) + ": " + Integer.toString(sp.left + 1) );
      cadena = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena;
      System.out.println(cadena );
        if(sym.T_dato == sp.sym){
              String cadena2= cadena;
              for(int j = i-1; j > 0; j--){                
                  sp = this.stack.get(j);
                  cadena2 = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena2;
                  if ("struct".equals(sp.value)) {

                    boolean set = false;

                    for (int r = this.stack.size() - 1; r > i; r--) {
                      Symbol toc = this.stack.get(r); 

                      if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
                          toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
                          toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
                        set = true;
                        erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
                        set = true;
                        erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
                          s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
                        set = true;
                        erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
                        set = true;
                        erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
                        set = true;
                        erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }         

                      if (toc.sym == sym.Not || s.sym == sym.Not) {
                        set = true;
                        erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                    }

                      Symbol sp3 = (this.stack.get(j+1).value == null ? this.stack.get(j+2) : this.stack.get(j+1));
                      cadena =sp.value+" "+sp3.value+" ... "+ cadena + "~" + s.value + "~ ...";
                      Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
                      errores.add(sp2);
                      if (!set) erroresStr.add("Struct_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                      break;
                  }
                  if("(".equals(sp.value)){
                      for(int k = j-1; k > 0; k--){ 
                          sp = this.stack.get(k);
                          cadena2 = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena2;
                          if ("function".equals(sp.value)) {
                              
                              cadena2 += "~" + s.value + "~ ...";
                              Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena2);
                              errores.add(sp2);
                              erroresStr.add("Parametro_Function"+" (" + Integer.toString(sp.right+1) + ")");
                              break;
                          }
                          if ("returns".equals(sp.value)) {
                              for(int l=k-1;l>0; l--){
                              sp = this.stack.get(l);
                              cadena2 = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena2;
                                if ("function".equals(sp.value)) {                             
                                    cadena2 += "~" + s.value + "~ ...";
                                    Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena2);
                                    errores.add(sp2);
                                    erroresStr.add("Returns_Function"+" (" + Integer.toString(sp.right+1) + ")");
                                    break;
                                }
                             }
                             break;
                          }
                      }
                      break;
                  }
                  if ("returns".equals(sp.value)) {
                              for(int k=j-1;k>0; k--){
                              sp = this.stack.get(k);
                              cadena2 = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena2;
                                if ("function".equals(sp.value)) {                             
                                    cadena2 += "~" + s.value + "~ ...";
                                    Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena2);
                                    errores.add(sp2);
                                    erroresStr.add("Returns_Function"+" (" + Integer.toString(sp.right+1) + ")");
                                    break;
                                }
                             }
                             
                             break;
                          }

                  if ("contract".equals(sp.value)){

                    boolean set = false;

                    for (int r = this.stack.size() - 1; r > i; r--) {
                      Symbol toc = this.stack.get(r); 

                      if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
                          toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
                          toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
                        set = true;
                        erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
                        set = true;
                        erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
                          s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
                        set = true;
                        erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
                        set = true;
                        erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
                        set = true;
                        erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }         

                      if (toc.sym == sym.Not || s.sym == sym.Not) {
                        set = true;
                        erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                    }

                      Symbol sp3 = (this.stack.get(j+1).value == null ? this.stack.get(j+2) : this.stack.get(j+1));
                      cadena =sp.value+" "+sp3.value+" ... "+ cadena + "~" + s.value + "~ ...";
                      Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
                      errores.add(sp2);
                      if (!set) erroresStr.add("Contract_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                      break;

                    //cadena += "~" + s.value + "~ ...";
                    //Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
                    //errores.add(sp2);
                    //if (!set) erroresStr.add("If"+" (" + Integer.toString(sp.right+1) + ")");
                    //break;




                  }
                  if ("function".equals(sp.value)){

                    boolean set = false;

                    for (int r = this.stack.size() - 1; r > i; r--) {
                      Symbol toc = this.stack.get(r); 

                      if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
                          toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
                          toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
                        set = true;
                        erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
                        set = true;
                        erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
                          s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
                        set = true;
                        erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                      if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
                        set = true;
                        erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }      
                      if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
                        set = true;
                        erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }         

                      if (toc.sym == sym.Not || s.sym == sym.Not) {
                        set = true;
                        erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                        break;
                      }
                    }

                      Symbol sp3 = (this.stack.get(j+1).value == null ? this.stack.get(j+2) : this.stack.get(j+1));
                      cadena =sp.value+" "+sp3.value+" ... "+ cadena + "~" + s.value + "~ ...";
                      Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
                      errores.add(sp2);
                      if (!set) erroresStr.add("Function_Variable"+" (" + Integer.toString(sp.right+1) + ")");
                      break;
                  }
              }
              break;  
        }
        if ("returns".equals(sp.value)) {
        System.out.println("Es aquí la verdad");
            for(int j=i-1;j>0; j--){
                sp = this.stack.get(j);
                cadena = ((sp.value == null) ? ".." :  sp.value)+ " " + cadena;
                  if ("function".equals(sp.value)) {   
                        System.out.println(cadena);
                      cadena += "~" + s.value + "~ ...";
                      Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
                      errores.add(sp2);
                      erroresStr.add("Returns_Function"+" (" + Integer.toString(sp.right+1) + ")");
                      break;
                  }
               }
               System.out.println("Toy aquí");
               break;
        }
      if ("enum".equals(sp.value)) {
        System.out.println("Soy un error de enum xd");
        //System.out.println("Soy un error de enum xd");
        cadena += "~" + s.value + "~ ...";
        //if (this.lookahead != null) for (Symbol x : this.lookahead) System.out.println(x.value);
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        erroresStr.add("Enum"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }
      if ("struct".equals(sp.value)) {
        //System.out.println("Soy un error de struct chama");
        cadena += "~" + s.value + "~ ...";
        //if (this.lookahead != null) for (Symbol x : this.lookahead) System.out.println(x.value);
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        erroresStr.add("Struct"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }
      if ("function".equals(sp.value)) {
        System.out.println("Soy un error de function chama!!!");

        boolean set = false;

        boolean duperFound = false;

          for (int x = this.stack.size() - 1; x > 0; x--) { 
              if ("function".equals(this.stack.get(x).value)) break;
              if ("{".equals(this.stack.get(x).value)) duperFound = true;
          } 
          if (!duperFound) {
              cadena += "~" + s.value + "~ ...";
              Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
              errores.add(sp2);
              erroresStr.add("Function"+" (" + Integer.toString(sp.right+1) + ")");
              break;
          } 

        for (int r = this.stack.size() - 1; r > i; r--) {
          Symbol toc = this.stack.get(r); 
          
          if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
              toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
              toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
              s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }         

          if (toc.sym == sym.Not || s.sym == sym.Not) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("function".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "function ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on Function"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
        }
        cadena += "~" + s.value + "~ ...";
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        if (!set) erroresStr.add("Function"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }
      if ("pragma".equals(sp.value)) {
        //System.out.println("Soy un error de inicio");
        cadena += "~" + s.value + "~ ...";
        //if (this.lookahead != null) for (Symbol x : this.lookahead) System.out.println(x.value);
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        erroresStr.add("File_Structure"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }/*
      if (";".equals(sp.value)) {
        //System.out.println("Soy un error de Expresion");
        cadena += "~" + s.value + "~ ...";
        //if (this.lookahead != null) for (Symbol x : this.lookahead) System.out.println(x.value);
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        erroresStr.add("Expression"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }*/
      if ("contract".equals(sp.value)) {
        //System.out.println("Soy un error de inicio");
        cadena += "~" + s.value + "~ ...";
        //if (this.lookahead != null) for (Symbol x : this.lookahead) System.out.println(x.value);
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        erroresStr.add("Contract"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }
      if ("if".equals(sp.value)) {
        //System.out.println("Soy un error de if");
        boolean set = false;

        for (int r = this.stack.size() - 1; r > i; r--) {
          Symbol toc = this.stack.get(r); 
          if (toc.sym == sym.Else || s.sym == sym.Else) {
            cadena = ""; boolean superSet = false, found = false, found2 = false; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            Symbol prev = (toc.sym == sym.Else) ? this.stack.get(r-1): this.stack.get(this.stack.size() - 1);
            if ("}".equals(prev.value)) erroresStr.add("Wrong_Else_Placement"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            else erroresStr.add("Missing_Closing_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            set = true;
            
            break;
          }      

          
          if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
              toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
              toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
            cadena = ""; boolean superSet = false, found = false, found2 = false; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
            cadena = ""; boolean superSet = false, found = false, found2 = false; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
              s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }         

          if (toc.sym == sym.Not || s.sym == sym.Not) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("if".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "if ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on If"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
        }
        cadena += "~" + s.value + "~ ...";
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        if (!set) erroresStr.add("If"+" (" + Integer.toString(sp.right+1) + ")");
        break;


      }
      if ("for".equals(sp.value)) {
        //System.out.println("Soy un error de for");
        boolean set = false;

        for (int r = this.stack.size() - 1; r > i; r--) {
          Symbol toc = this.stack.get(r); 
          
          if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
              toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
              toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
            cadena = ""; boolean superSet = false, found = false, found2 = false; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
            cadena = ""; boolean superSet = false, found = false, found2 = false; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
              s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }         

          if (toc.sym == sym.Not || s.sym == sym.Not) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("for".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "for ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on For"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
        }
        cadena += "~" + s.value + "~ ...";
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        if (!set) erroresStr.add("For"+" (" + Integer.toString(sp.right+1) + ")");
        break;




      }
      if ("while".equals(sp.value)) {
        //System.out.println("Soy un error de while");
        boolean set = false;

        for (int r = this.stack.size() - 1; r > i; r--) {
          Symbol toc = this.stack.get(r); 
          
          if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
              toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
              toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
              s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }         

          if (toc.sym == sym.Not || s.sym == sym.Not) {
            cadena = ""; boolean superSet = false, found = false, found2 = false;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if (")".equals(this.stack.get(x).value)) found2 = true;
                if ("while".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "while ( .. ) ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on While"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
        }
        cadena += "~" + s.value + "~ ...";
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        if (!set) erroresStr.add("While"+" (" + Integer.toString(sp.right+1) + ")");
        break;
      }
      if ("do".equals(sp.value)) {
        //System.out.println("Soy un error de do");
        boolean set = false;

        for (int r = this.stack.size() - 1; r > i; r--) {
          Symbol toc = this.stack.get(r); 
          
          if ((toc.sym == sym.Numero || s.sym == sym.Numero ||  
              toc.sym == sym.String || s.sym == sym.String || toc.sym == sym.Identificador || s.sym == sym.Identificador || 
              toc.sym == sym.Op_booleano || s.sym == sym.Op_booleano) && (toc.value != null)) {
            cadena = ""; boolean superSet = false, found = false, found2 = true;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Dos_Puntos || s.sym == sym.Dos_Puntos || toc.sym == sym.Pregunta || s.sym == sym.Pregunta) {
            cadena = ""; boolean superSet = false, found = false, found2 = true; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Wrong_Ternary_Operator"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_atribucion || s.sym == sym.Op_atribucion || toc.sym == sym.Igual || s.sym == sym.Igual) {
            cadena = ""; boolean superSet = false, found = false, found2 = true; 
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Assignment_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }      
          if (toc.sym == sym.Op_Aritmetico || toc.sym == sym.Op_logico || toc.sym == sym.Mas || toc.sym == sym.Menos ||
              s.sym == sym.Op_Aritmetico || s.sym == sym.Op_logico || s.sym == sym.Mas || s.sym == sym.Menos) {
            cadena = ""; boolean superSet = false, found = false, found2 = true;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_Operand"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
          if (toc.sym == sym.Parentesis_c || s.sym == sym.Parentesis_c || toc.sym == sym.Parentesis_a || s.sym == sym.Parentesis_a) {
            cadena = ""; boolean superSet = false, found = false, found2 = true;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Parenthesis_Or_Expression"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }         

          if (toc.sym == sym.Not || s.sym == sym.Not) {
            cadena = ""; boolean superSet = false, found = false, found2 = true;  
            for (int x = this.stack.size() - 1; x > 0; x--) { 
                if ("{".equals(this.stack.get(x).value)) found = true;
                if ("do".equals(this.stack.get(x).value)) { 
                    cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena; 
                    superSet = true; break; 
                }
                if (";".equals(this.stack.get(x).value) || "{".equals(this.stack.get(x).value)) break; 
                cadena = ((this.stack.get(x).value == null) ? ".." :  this.stack.get(x).value)+ " " + cadena;
            } 
            if (!superSet) cadena = "do ... " + cadena;           
            if (superSet && !found && found2) {set = true;
                erroresStr.add("Missing_Opening_Bracket"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
                break;
            }
            set = true;
            erroresStr.add("Missing_Expression_On_Not"+" (" + Integer.toString(toc.right+1) + ")" + " on Do"+" (" + Integer.toString(sp.right+1) + ")");
            break;
          }
        }
        cadena += "~" + s.value + "~ ...";
        Symbol sp2 = new Symbol(s.sym, s.left, s.right, cadena);
        errores.add(sp2);
        if (!set) erroresStr.add("Do"+" (" + Integer.toString(sp.right+1) + ")");
        break;



      }
        }
  }
  @Override
  public int error_sync_size() {
    return 2;
  }

:};

terminal Linea, Comillas, T_dato, Cadena, If, Else, Do, While, For, Dos_Puntos,
    Igual, Op_logico, Op_relacional, Op_atribucion, Op_booleano, Parentesis_a, Parentesis_c,
    Llave_a, Llave_c, Corchete_a, Corchete_c, Main, P_coma, Identificador, Mas, Menos, Not,
    Numero,   Contract, Enum, Pragma, Solidity, Struct,Function,Modificador, Coma, Caret, Punto, This, Break, Continue, 
    String, Return, Returns,  Op_Aritmetico, Visibilidad, Pregunta, PALABRA_RESERVADA, UNIDAD, TRANSAC,ERROR_CEROS_A_LA_IZQUIERDA, ERROR_CARACTERES_NO_VALIDOS, ERROR_IDENTIFICADOR
    , ERROR_NOTACION_CIENTIFICA, STRING, ERROR_STRING, OPERADOR, ERROR_COMENTARIO,ERROR_HEXADECIMAL,  ERROR;

non terminal INICIO, CONTRATO, OP_TERNARIO, DECLARACION_FOR, IF, IF_ELSE, LISTA, PARAMETROS, OP_ARITMETICO, OP_UNARIO, 
    WHILE, DO_WHILE, FOR, EXPRESION_BOOLEANA, SENTENCIA, SENTENCIA_FOR, ENUMERADOR, VARIABLES, ASIGNACION, ESTRUCTURA, IDENTIFICADOR_COMPLEJO,
    FUNCION, MODIFICADORES, RETURNS, CUERPO, FUNCION_HEADER, ASIGNACION_BASICA, ASIGNACION_COMPLEJA, ARGUMENTOS,
    EXPRESION, ESTRUCTURA_CONTROL, IDENTIFICADOR_CUERPO, CUERPO_EC, EXPRESION_TERM, ATRIBUCION_IGUAL, LITERAL ;

start with INICIO;

INICIO ::= 
    Pragma Solidity Numero Numero P_coma CONTRATO |
    Pragma Solidity Caret Numero Numero P_coma CONTRATO |
    Pragma error P_coma CONTRATO |
    Pragma Solidity Caret Numero Numero P_coma error CONTRATO
;
CONTRATO ::=
    Contract Identificador Llave_a Llave_c CONTRATO |

    Contract Identificador Llave_a ENUMERADOR Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR VARIABLES Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR ESTRUCTURA Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR FUNCION Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR VARIABLES ESTRUCTURA Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR VARIABLES FUNCION Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR ESTRUCTURA FUNCION Llave_c CONTRATO |
    Contract Identificador Llave_a ENUMERADOR VARIABLES ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract Identificador Llave_a VARIABLES Llave_c CONTRATO |
    Contract Identificador Llave_a VARIABLES ESTRUCTURA Llave_c CONTRATO |
    Contract Identificador Llave_a VARIABLES FUNCION Llave_c CONTRATO |
    Contract Identificador Llave_a VARIABLES ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract Identificador Llave_a ESTRUCTURA Llave_c CONTRATO |
    Contract Identificador Llave_a ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract Identificador Llave_a FUNCION Llave_c CONTRATO |

    Contract Identificador Llave_a Llave_c |

    Contract Identificador Llave_a ENUMERADOR Llave_c |
    Contract Identificador Llave_a ENUMERADOR VARIABLES Llave_c |
    Contract Identificador Llave_a ENUMERADOR ESTRUCTURA Llave_c |
    Contract Identificador Llave_a ENUMERADOR FUNCION Llave_c |
    Contract Identificador Llave_a ENUMERADOR VARIABLES ESTRUCTURA Llave_c |
    Contract Identificador Llave_a ENUMERADOR VARIABLES FUNCION Llave_c |
    Contract Identificador Llave_a ENUMERADOR ESTRUCTURA FUNCION Llave_c |
    Contract Identificador Llave_a ENUMERADOR VARIABLES ESTRUCTURA FUNCION Llave_c |

    Contract Identificador Llave_a VARIABLES Llave_c |
    Contract Identificador Llave_a VARIABLES ESTRUCTURA Llave_c |
    Contract Identificador Llave_a VARIABLES FUNCION Llave_c |
    Contract Identificador Llave_a VARIABLES ESTRUCTURA FUNCION Llave_c |

    Contract Identificador Llave_a ESTRUCTURA Llave_c |
    Contract Identificador Llave_a ESTRUCTURA FUNCION Llave_c |

    Contract Identificador Llave_a FUNCION Llave_c | 

    Contract error Llave_a Llave_c CONTRATO |

    Contract error Llave_a ENUMERADOR Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR VARIABLES Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR ESTRUCTURA Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR FUNCION Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR VARIABLES ESTRUCTURA Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR VARIABLES FUNCION Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR ESTRUCTURA FUNCION Llave_c CONTRATO |
    Contract error Llave_a ENUMERADOR VARIABLES ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract error Llave_a VARIABLES Llave_c CONTRATO |
    Contract error Llave_a VARIABLES ESTRUCTURA Llave_c CONTRATO |
    Contract error Llave_a VARIABLES FUNCION Llave_c CONTRATO |
    Contract error Llave_a VARIABLES ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract error Llave_a ESTRUCTURA Llave_c CONTRATO |
    Contract error Llave_a ESTRUCTURA FUNCION Llave_c CONTRATO |

    Contract error Llave_a FUNCION Llave_c CONTRATO |

    Contract error Llave_a Llave_c |

    Contract error Llave_a ENUMERADOR Llave_c |
    Contract error Llave_a ENUMERADOR VARIABLES Llave_c |
    Contract error Llave_a ENUMERADOR ESTRUCTURA Llave_c |
    Contract error Llave_a ENUMERADOR FUNCION Llave_c |
    Contract error Llave_a ENUMERADOR VARIABLES ESTRUCTURA Llave_c |
    Contract error Llave_a ENUMERADOR VARIABLES FUNCION Llave_c |
    Contract error Llave_a ENUMERADOR ESTRUCTURA FUNCION Llave_c |
    Contract error Llave_a ENUMERADOR VARIABLES ESTRUCTURA FUNCION Llave_c |

    Contract error Llave_a VARIABLES Llave_c |
    Contract error Llave_a VARIABLES ESTRUCTURA Llave_c |
    Contract error Llave_a VARIABLES FUNCION Llave_c |
    Contract error Llave_a VARIABLES ESTRUCTURA FUNCION Llave_c |

    Contract error Llave_a ESTRUCTURA Llave_c |
    Contract error Llave_a ESTRUCTURA FUNCION Llave_c |

    Contract error Llave_a FUNCION Llave_c 

    
;
ENUMERADOR ::= 
    Enum Identificador Llave_a LISTA Llave_c ENUMERADOR |
    Enum Identificador Llave_a Llave_c ENUMERADOR |
    Enum Identificador Llave_a LISTA Llave_c |
    Enum Identificador Llave_a Llave_c |

    Enum error Llave_a LISTA Llave_c ENUMERADOR |
    Enum error Llave_a Llave_c ENUMERADOR |

    Enum Identificador error LISTA Llave_c ENUMERADOR |
    Enum Identificador error Llave_c ENUMERADOR |

    Enum error Llave_a LISTA Llave_c | 
    Enum error Llave_a Llave_c |

    Enum Identificador error LISTA Llave_c |
    Enum Identificador error Llave_c 
;
LISTA ::= 
    Identificador Coma LISTA |
    Identificador
;
VARIABLES ::=
    T_dato Visibilidad LISTA P_coma VARIABLES |
    T_dato LISTA P_coma VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad LISTA P_coma VARIABLES |
    T_dato Corchete_a Corchete_c LISTA P_coma VARIABLES |

    T_dato Visibilidad LISTA ASIGNACION P_coma VARIABLES |
    T_dato LISTA ASIGNACION P_coma VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad LISTA ASIGNACION P_coma VARIABLES |
    T_dato Corchete_a Corchete_c LISTA ASIGNACION P_coma VARIABLES |

    T_dato Visibilidad LISTA P_coma |
    T_dato LISTA P_coma |
    T_dato Corchete_a Corchete_c Visibilidad LISTA P_coma |
    T_dato Corchete_a Corchete_c LISTA P_coma |

    T_dato Visibilidad LISTA ASIGNACION P_coma |
    T_dato LISTA ASIGNACION P_coma |
    T_dato Corchete_a Corchete_c Visibilidad LISTA ASIGNACION P_coma |
    T_dato Corchete_a Corchete_c LISTA ASIGNACION P_coma |



    T_dato Visibilidad error P_coma VARIABLES |
    T_dato error P_coma VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad error P_coma VARIABLES |
    T_dato Corchete_a Corchete_c error P_coma VARIABLES |

    T_dato Visibilidad error ASIGNACION P_coma VARIABLES |
    T_dato error ASIGNACION P_coma VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad error ASIGNACION P_coma VARIABLES |
    T_dato Corchete_a Corchete_c error ASIGNACION P_coma VARIABLES |

    T_dato Visibilidad error P_coma |
    T_dato error P_coma |
    T_dato Corchete_a Corchete_c Visibilidad error P_coma |
    T_dato Corchete_a Corchete_c error P_coma |

    T_dato Visibilidad error ASIGNACION P_coma |
    T_dato error ASIGNACION P_coma |
    T_dato Corchete_a Corchete_c Visibilidad error ASIGNACION P_coma |
    T_dato Corchete_a Corchete_c error ASIGNACION P_coma |




    T_dato error Corchete_c Visibilidad LISTA P_coma VARIABLES |
    T_dato error Corchete_c LISTA P_coma VARIABLES |

    T_dato error Corchete_c Visibilidad LISTA ASIGNACION P_coma VARIABLES |
    T_dato error Corchete_c LISTA ASIGNACION P_coma VARIABLES |

    T_dato error Corchete_c Visibilidad LISTA P_coma |
    T_dato error Corchete_c LISTA P_coma |

    T_dato error Corchete_c Visibilidad LISTA ASIGNACION P_coma |
    T_dato error Corchete_c LISTA ASIGNACION P_coma |



    T_dato Corchete_a error Visibilidad LISTA P_coma VARIABLES |
    T_dato Corchete_a error LISTA P_coma VARIABLES |

    T_dato Corchete_a error Visibilidad LISTA ASIGNACION P_coma VARIABLES |
    T_dato Corchete_a error LISTA ASIGNACION P_coma VARIABLES |

    T_dato Corchete_a error Visibilidad LISTA P_coma |
    T_dato Corchete_a error LISTA P_coma |

    T_dato Corchete_a error Visibilidad LISTA ASIGNACION P_coma |
    T_dato Corchete_a error LISTA ASIGNACION P_coma |


    T_dato error Corchete_c Visibilidad error P_coma VARIABLES |
    T_dato error Corchete_c error P_coma VARIABLES |

    T_dato error Corchete_c Visibilidad error ASIGNACION P_coma VARIABLES |
    T_dato error Corchete_c error ASIGNACION P_coma VARIABLES |

    T_dato error Corchete_c Visibilidad error P_coma |
    T_dato error Corchete_c error P_coma |

    T_dato error Corchete_c Visibilidad error ASIGNACION P_coma |
    T_dato error Corchete_c error ASIGNACION P_coma |

    T_dato Visibilidad LISTA error VARIABLES |
    T_dato LISTA error VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad LISTA error VARIABLES |
    T_dato Corchete_a Corchete_c LISTA error VARIABLES |

    T_dato Visibilidad LISTA ASIGNACION error VARIABLES |
    T_dato LISTA ASIGNACION error VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad LISTA ASIGNACION error VARIABLES |
    T_dato Corchete_a Corchete_c LISTA ASIGNACION error VARIABLES |

    T_dato Visibilidad LISTA error |
    T_dato LISTA error |
    T_dato Corchete_a Corchete_c Visibilidad LISTA error |
    T_dato Corchete_a Corchete_c LISTA error |

    T_dato Visibilidad LISTA ASIGNACION error |
    T_dato LISTA ASIGNACION error |
    T_dato Corchete_a Corchete_c Visibilidad LISTA ASIGNACION error |
    T_dato Corchete_a Corchete_c LISTA ASIGNACION error |




    T_dato Visibilidad error VARIABLES |
    T_dato error VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad error VARIABLES |
    T_dato Corchete_a Corchete_c error VARIABLES |

    T_dato Visibilidad error ASIGNACION error VARIABLES |
    T_dato error ASIGNACION error VARIABLES |
    T_dato Corchete_a Corchete_c Visibilidad error ASIGNACION error VARIABLES |
    T_dato Corchete_a Corchete_c error ASIGNACION error VARIABLES |

    T_dato Visibilidad error |
    T_dato error |
    T_dato Corchete_a Corchete_c Visibilidad error |
    T_dato Corchete_a Corchete_c error |

    T_dato Visibilidad error ASIGNACION error |
    T_dato error ASIGNACION error |
    T_dato Corchete_a Corchete_c Visibilidad error ASIGNACION error |
    T_dato Corchete_a Corchete_c error ASIGNACION error |
    
    

    T_dato error Corchete_c Visibilidad error VARIABLES |
    T_dato Corchete_a error Visibilidad error VARIABLES |
    T_dato Corchete_a error VARIABLES |
    T_dato error Corchete_c error VARIABLES |

    T_dato error Corchete_c Visibilidad error ASIGNACION error VARIABLES |
    T_dato Corchete_a error Visibilidad error ASIGNACION error VARIABLES |
    T_dato Corchete_a error ASIGNACION error VARIABLES |
    T_dato error Corchete_c error ASIGNACION error VARIABLES |

    T_dato error Corchete_c Visibilidad error  |
    T_dato Corchete_a error Visibilidad error  |
    T_dato error Corchete_c error  |

    T_dato error Corchete_c Visibilidad error ASIGNACION error  |
    T_dato Corchete_a error Visibilidad error ASIGNACION error  |
    T_dato Corchete_a error ASIGNACION error  |
    T_dato error Corchete_c error ASIGNACION error 
;
ASIGNACION ::= 
    Igual EXPRESION
;
ESTRUCTURA ::=
    Struct Identificador Llave_a VARIABLES Llave_c ESTRUCTURA |
    Struct Identificador Llave_a Llave_c ESTRUCTURA |
    Struct Identificador Llave_a VARIABLES Llave_c |
    Struct Identificador Llave_a Llave_c |

    Struct error Llave_a VARIABLES Llave_c ESTRUCTURA |
    Struct error Llave_a Llave_c ESTRUCTURA |
    Struct error Llave_a VARIABLES Llave_c |
    Struct error Llave_a Llave_c |

    Struct Identificador error VARIABLES Llave_c ESTRUCTURA |
    Struct Identificador error Llave_c ESTRUCTURA |
    Struct Identificador error VARIABLES Llave_c |
    Struct Identificador error Llave_c |
    

    Struct Identificador Llave_a VARIABLES error ESTRUCTURA |
    Struct Identificador Llave_a error ESTRUCTURA |
    Struct Identificador Llave_a VARIABLES error |
    Struct Identificador Llave_a error |

    Struct error VARIABLES Llave_c ESTRUCTURA |
    Struct error Llave_c ESTRUCTURA |
    Struct error VARIABLES Llave_c |
    Struct error Llave_c |
    
    Struct Identificador error VARIABLES error ESTRUCTURA |
    Struct Identificador error ESTRUCTURA |
    Struct Identificador error VARIABLES error |

    Struct error Llave_a VARIABLES error ESTRUCTURA |
    Struct error Llave_a error ESTRUCTURA |
    Struct error Llave_a VARIABLES error |
    Struct error Llave_a error |

    Struct error ESTRUCTURA    
;
FUNCION_HEADER ::=

    Parentesis_a PARAMETROS Parentesis_c MODIFICADORES RETURNS |
    Parentesis_a PARAMETROS Parentesis_c MODIFICADORES |
    Parentesis_a PARAMETROS Parentesis_c RETURNS |
    Parentesis_a PARAMETROS Parentesis_c |    
    
     Parentesis_a  Parentesis_c MODIFICADORES RETURNS |
     Parentesis_a  Parentesis_c MODIFICADORES |
     Parentesis_a  Parentesis_c RETURNS |
     Parentesis_a  Parentesis_c |
    
     error  PARAMETROS Parentesis_c |
     error  PARAMETROS Parentesis_c MODIFICADORES |
     error  PARAMETROS Parentesis_c RETURNS |
     error  PARAMETROS Parentesis_c MODIFICADORES RETURNS |
     error  Parentesis_c |
     error  Parentesis_c MODIFICADORES |
     error  Parentesis_c RETURNS |
     error  Parentesis_c MODIFICADORES RETURNS |
    
     Parentesis_a PARAMETROS error | 
     Parentesis_a PARAMETROS error MODIFICADORES |
     Parentesis_a PARAMETROS error RETURNS |
     Parentesis_a PARAMETROS error MODIFICADORES RETURNS |
     Parentesis_a  error MODIFICADORES |
     Parentesis_a  error RETURNS |
     Parentesis_a  error MODIFICADORES RETURNS |


     error  PARAMETROS error |
     error  PARAMETROS error MODIFICADORES |
     error  PARAMETROS error RETURNS |
     error  PARAMETROS error MODIFICADORES RETURNS |
     error  MODIFICADORES |
     error  RETURNS |
     error  MODIFICADORES RETURNS 

;
FUNCION ::=
    Function Identificador FUNCION_HEADER Llave_a VARIABLES Llave_c FUNCION |
    Function Identificador FUNCION_HEADER Llave_a VARIABLES CUERPO Llave_c FUNCION |
    Function Identificador FUNCION_HEADER Llave_a CUERPO Llave_c FUNCION |
    Function Identificador FUNCION_HEADER Llave_a Llave_c FUNCION |
    Function Identificador FUNCION_HEADER Llave_a VARIABLES Llave_c |
    Function Identificador FUNCION_HEADER Llave_a VARIABLES CUERPO Llave_c |
    Function Identificador FUNCION_HEADER Llave_a CUERPO Llave_c |
    Function Identificador FUNCION_HEADER Llave_a Llave_c |
    
    Function error FUNCION_HEADER Llave_a VARIABLES Llave_c FUNCION |
    Function error FUNCION_HEADER Llave_a VARIABLES CUERPO Llave_c FUNCION |
    Function error FUNCION_HEADER Llave_a CUERPO Llave_c FUNCION |
    Function error FUNCION_HEADER Llave_a Llave_c FUNCION |
    Function error FUNCION_HEADER Llave_a VARIABLES Llave_c |
    Function error FUNCION_HEADER Llave_a VARIABLES CUERPO Llave_c |
    Function error FUNCION_HEADER Llave_a CUERPO Llave_c |
    Function error FUNCION_HEADER Llave_a Llave_c |

    Function Identificador FUNCION_HEADER error VARIABLES Llave_c FUNCION |
    Function Identificador FUNCION_HEADER error VARIABLES CUERPO Llave_c FUNCION |
    Function Identificador FUNCION_HEADER error CUERPO Llave_c FUNCION |
    Function Identificador FUNCION_HEADER error Llave_c FUNCION |
    Function Identificador FUNCION_HEADER error VARIABLES Llave_c |
    Function Identificador FUNCION_HEADER error VARIABLES CUERPO Llave_c |
    Function Identificador FUNCION_HEADER error CUERPO Llave_c |
    Function Identificador FUNCION_HEADER error Llave_c |
    
    Function error FUNCION_HEADER error VARIABLES Llave_c FUNCION |
    Function error FUNCION_HEADER error VARIABLES CUERPO Llave_c FUNCION |
    Function error FUNCION_HEADER error CUERPO Llave_c FUNCION |
    Function error FUNCION_HEADER error Llave_c FUNCION |
    Function error FUNCION_HEADER error VARIABLES Llave_c |
    Function error FUNCION_HEADER error VARIABLES CUERPO Llave_c |
    Function error FUNCION_HEADER error CUERPO Llave_c |
    Function error FUNCION_HEADER error Llave_c |

    Function Identificador FUNCION_HEADER Llave_a error Llave_c FUNCION |
    Function Identificador FUNCION_HEADER Llave_a error Llave_c 
;
RETURNS ::= 
    Returns Parentesis_a T_dato Identificador  Parentesis_c|
    Returns Parentesis_a Parentesis_c  |
    Returns error T_dato Identificador Parentesis_c |
    Returns Parentesis_a T_dato error Parentesis_c |
    Returns Parentesis_a T_dato Identificador error |
    Returns Parentesis_a error Identificador Parentesis_c |

    Returns error T_dato Identificador error |
    Returns Parentesis_a T_dato error |
    Returns Parentesis_a error Identificador error |

    Returns error T_dato error Parentesis_c | 

    Returns error Identificador Parentesis_c |

    Returns error Parentesis_c |
    Returns Parentesis_a error |
    Returns error T_dato error |
    Returns error Identificador error    
;
PARAMETROS ::=
    T_dato Identificador Coma PARAMETROS |
    T_dato Identificador |
    error Identificador Coma PARAMETROS |
    error Coma PARAMETROS|
    error Identificador |
    T_dato error Coma PARAMETROS |
    T_dato error |
    error
    
;
MODIFICADORES ::=
    Modificador MODIFICADORES |
    Visibilidad MODIFICADORES |
    Modificador |
    Visibilidad 
;
CUERPO ::=
    EXPRESION P_coma CUERPO |
    ESTRUCTURA_CONTROL CUERPO |
    error P_coma CUERPO |
    error CUERPO |

    EXPRESION P_coma |
    ESTRUCTURA_CONTROL 
;
IDENTIFICADOR_COMPLEJO ::=
    This Parentesis_a Parentesis_c |
    This Parentesis_a ARGUMENTOS Parentesis_c |
    This |
    Identificador Parentesis_a Parentesis_c |
    Identificador Parentesis_a ARGUMENTOS Parentesis_c |
    Identificador
;
IDENTIFICADOR_CUERPO ::=
    IDENTIFICADOR_COMPLEJO Punto IDENTIFICADOR_CUERPO  |
    IDENTIFICADOR_COMPLEJO
;
ASIGNACION_BASICA ::= 
    IDENTIFICADOR_CUERPO ATRIBUCION_IGUAL EXPRESION_TERM |
    LITERAL ATRIBUCION_IGUAL EXPRESION_TERM
;
ASIGNACION_COMPLEJA ::= 
    IDENTIFICADOR_CUERPO ATRIBUCION_IGUAL EXPRESION |
    T_dato Identificador Igual EXPRESION 
;
ATRIBUCION_IGUAL ::=
    Op_atribucion |
    Igual
;
ARGUMENTOS ::=
    EXPRESION Coma ARGUMENTOS |
    EXPRESION
;
LITERAL ::= 
    Numero |
    String |
    Op_booleano
;
EXPRESION ::=
    EXPRESION OP_ARITMETICO EXPRESION_TERM |
    EXPRESION Op_logico EXPRESION_TERM |
    EXPRESION OP_ARITMETICO error |
    EXPRESION Op_logico error |

    EXPRESION_TERM 
;

EXPRESION_TERM ::= 
    Parentesis_a EXPRESION Parentesis_c |

    OP_UNARIO EXPRESION_TERM |
    ASIGNACION_BASICA |
    OP_TERNARIO |

    LITERAL |
    IDENTIFICADOR_CUERPO  

;
OP_ARITMETICO ::=
    Op_Aritmetico |
    Mas |
    Menos
;
OP_UNARIO ::=
    Mas |
    Menos |
    Not
;
ESTRUCTURA_CONTROL ::= 
    IF_ELSE |
    IF | 
    WHILE |
    DO_WHILE |
    FOR |
    Return EXPRESION P_coma
;
SENTENCIA ::=
    IF_ELSE |
    IF | 
    WHILE |
    DO_WHILE |
    FOR |
    Break P_coma |
    Continue P_coma |
    Return EXPRESION P_coma
;
CUERPO_EC ::=
    EXPRESION P_coma CUERPO_EC |
    SENTENCIA CUERPO_EC |
    error P_coma CUERPO_EC |
    error CUERPO_EC |

    EXPRESION P_coma |
    SENTENCIA 
;
OP_TERNARIO ::= 
    Parentesis_a EXPRESION Parentesis_c Pregunta EXPRESION Dos_Puntos EXPRESION_TERM
;
IF ::= 
    If Parentesis_a EXPRESION Parentesis_c Llave_a CUERPO_EC Llave_c |
    If Parentesis_a EXPRESION Parentesis_c Llave_a Llave_c |
    If error Parentesis_c Llave_a CUERPO_EC Llave_c |
    If error Parentesis_c Llave_a Llave_c |
    If Parentesis_a EXPRESION Parentesis_c error CUERPO_EC Llave_c |
    If Parentesis_a EXPRESION Parentesis_c error Llave_c 
;
EXPRESION_BOOLEANA ::= 
    P_coma
;
IF_ELSE ::= 
    If Parentesis_a EXPRESION Parentesis_c Llave_a CUERPO_EC Llave_c Else Llave_a CUERPO_EC Llave_c |
    If Parentesis_a EXPRESION Parentesis_c Llave_a CUERPO_EC Llave_c Else Llave_a Llave_c |
    If Parentesis_a EXPRESION Parentesis_c Llave_a Llave_c Else Llave_a CUERPO_EC Llave_c |
    If Parentesis_a EXPRESION Parentesis_c Llave_a Llave_c Else Llave_a Llave_c |

    If error Parentesis_c Llave_a CUERPO_EC Llave_c Else Llave_a CUERPO_EC Llave_c |
    If error Parentesis_c Llave_a CUERPO_EC Llave_c Else Llave_a Llave_c |
    If error Parentesis_c Llave_a Llave_c Else Llave_a CUERPO_EC Llave_c |
    If error Parentesis_c Llave_a Llave_c Else Llave_a Llave_c 
    
;
WHILE ::= 
    While Parentesis_a EXPRESION Parentesis_c Llave_a CUERPO_EC Llave_c |
    While Parentesis_a EXPRESION Parentesis_c Llave_a Llave_c |

    While error Parentesis_c Llave_a CUERPO_EC Llave_c |
    While error Parentesis_c Llave_a Llave_c |
    While Parentesis_a EXPRESION Parentesis_c error CUERPO_EC Llave_c |
    While Parentesis_a EXPRESION Parentesis_c error Llave_c 
;
DO_WHILE ::= 
    Do Llave_a CUERPO_EC Llave_c While Parentesis_a EXPRESION Parentesis_c P_coma |
    Do Llave_a Llave_c While Parentesis_a EXPRESION Parentesis_c P_coma |

    Do error CUERPO_EC Llave_c While Parentesis_a EXPRESION Parentesis_c P_coma |
    Do error Llave_c While Parentesis_a EXPRESION Parentesis_c P_coma |
    Do Llave_a CUERPO_EC Llave_c error P_coma |
    Do Llave_a Llave_c error P_coma 
;
FOR ::= 
    For Parentesis_a SENTENCIA_FOR Parentesis_c Llave_a CUERPO_EC Llave_c |
    For Parentesis_a SENTENCIA_FOR Parentesis_c Llave_a Llave_c |

    For error Parentesis_c Llave_a CUERPO_EC Llave_c |
    For error Parentesis_c Llave_a Llave_c  |
    For Parentesis_a SENTENCIA_FOR Parentesis_c error CUERPO_EC Llave_c |
    For Parentesis_a SENTENCIA_FOR Parentesis_c error Llave_c 
;
SENTENCIA_FOR ::=
    ASIGNACION_COMPLEJA P_coma EXPRESION P_coma EXPRESION 
;




